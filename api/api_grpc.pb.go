// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: api/api.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ClientServerTxnsClient is the client API for ClientServerTxns service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClientServerTxnsClient interface {
	Request(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Reply, error)
	SimulateNodeFailure(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Blank, error)
	SimulateLeaderFailure(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Blank, error)
	RecoverNode(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Blank, error)
	GetBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceReply, error)
	Prepare2PC(ctx context.Context, in *Prepare2PCRequest, opts ...grpc.CallOption) (*Prepare2PCReply, error)
	Decide2PC(ctx context.Context, in *Decide2PCRequest, opts ...grpc.CallOption) (*Blank, error)
}

type clientServerTxnsClient struct {
	cc grpc.ClientConnInterface
}

func NewClientServerTxnsClient(cc grpc.ClientConnInterface) ClientServerTxnsClient {
	return &clientServerTxnsClient{cc}
}

func (c *clientServerTxnsClient) Request(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Reply, error) {
	out := new(Reply)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/Request", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientServerTxnsClient) SimulateNodeFailure(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Blank, error) {
	out := new(Blank)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/SimulateNodeFailure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientServerTxnsClient) SimulateLeaderFailure(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Blank, error) {
	out := new(Blank)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/SimulateLeaderFailure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientServerTxnsClient) RecoverNode(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Blank, error) {
	out := new(Blank)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/RecoverNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientServerTxnsClient) GetBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceReply, error) {
	out := new(BalanceReply)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientServerTxnsClient) Prepare2PC(ctx context.Context, in *Prepare2PCRequest, opts ...grpc.CallOption) (*Prepare2PCReply, error) {
	out := new(Prepare2PCReply)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/Prepare2PC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientServerTxnsClient) Decide2PC(ctx context.Context, in *Decide2PCRequest, opts ...grpc.CallOption) (*Blank, error) {
	out := new(Blank)
	err := c.cc.Invoke(ctx, "/api.ClientServerTxns/Decide2PC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClientServerTxnsServer is the server API for ClientServerTxns service.
// All implementations must embed UnimplementedClientServerTxnsServer
// for forward compatibility
type ClientServerTxnsServer interface {
	Request(context.Context, *Message) (*Reply, error)
	SimulateNodeFailure(context.Context, *Blank) (*Blank, error)
	SimulateLeaderFailure(context.Context, *Blank) (*Blank, error)
	RecoverNode(context.Context, *Blank) (*Blank, error)
	GetBalance(context.Context, *BalanceRequest) (*BalanceReply, error)
	Prepare2PC(context.Context, *Prepare2PCRequest) (*Prepare2PCReply, error)
	Decide2PC(context.Context, *Decide2PCRequest) (*Blank, error)
	mustEmbedUnimplementedClientServerTxnsServer()
}

// UnimplementedClientServerTxnsServer must be embedded to have forward compatible implementations.
type UnimplementedClientServerTxnsServer struct {
}

func (UnimplementedClientServerTxnsServer) Request(context.Context, *Message) (*Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Request not implemented")
}
func (UnimplementedClientServerTxnsServer) SimulateNodeFailure(context.Context, *Blank) (*Blank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateNodeFailure not implemented")
}
func (UnimplementedClientServerTxnsServer) SimulateLeaderFailure(context.Context, *Blank) (*Blank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateLeaderFailure not implemented")
}
func (UnimplementedClientServerTxnsServer) RecoverNode(context.Context, *Blank) (*Blank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecoverNode not implemented")
}
func (UnimplementedClientServerTxnsServer) GetBalance(context.Context, *BalanceRequest) (*BalanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedClientServerTxnsServer) Prepare2PC(context.Context, *Prepare2PCRequest) (*Prepare2PCReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare2PC not implemented")
}
func (UnimplementedClientServerTxnsServer) Decide2PC(context.Context, *Decide2PCRequest) (*Blank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decide2PC not implemented")
}
func (UnimplementedClientServerTxnsServer) mustEmbedUnimplementedClientServerTxnsServer() {}

// UnsafeClientServerTxnsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClientServerTxnsServer will
// result in compilation errors.
type UnsafeClientServerTxnsServer interface {
	mustEmbedUnimplementedClientServerTxnsServer()
}

func RegisterClientServerTxnsServer(s grpc.ServiceRegistrar, srv ClientServerTxnsServer) {
	s.RegisterService(&ClientServerTxns_ServiceDesc, srv)
}

func _ClientServerTxns_Request_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).Request(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/Request",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).Request(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientServerTxns_SimulateNodeFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Blank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).SimulateNodeFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/SimulateNodeFailure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).SimulateNodeFailure(ctx, req.(*Blank))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientServerTxns_SimulateLeaderFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Blank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).SimulateLeaderFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/SimulateLeaderFailure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).SimulateLeaderFailure(ctx, req.(*Blank))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientServerTxns_RecoverNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Blank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).RecoverNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/RecoverNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).RecoverNode(ctx, req.(*Blank))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientServerTxns_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).GetBalance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientServerTxns_Prepare2PC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Prepare2PCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).Prepare2PC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/Prepare2PC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).Prepare2PC(ctx, req.(*Prepare2PCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClientServerTxns_Decide2PC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Decide2PCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientServerTxnsServer).Decide2PC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.ClientServerTxns/Decide2PC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientServerTxnsServer).Decide2PC(ctx, req.(*Decide2PCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClientServerTxns_ServiceDesc is the grpc.ServiceDesc for ClientServerTxns service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClientServerTxns_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.ClientServerTxns",
	HandlerType: (*ClientServerTxnsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Request",
			Handler:    _ClientServerTxns_Request_Handler,
		},
		{
			MethodName: "SimulateNodeFailure",
			Handler:    _ClientServerTxns_SimulateNodeFailure_Handler,
		},
		{
			MethodName: "SimulateLeaderFailure",
			Handler:    _ClientServerTxns_SimulateLeaderFailure_Handler,
		},
		{
			MethodName: "RecoverNode",
			Handler:    _ClientServerTxns_RecoverNode_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _ClientServerTxns_GetBalance_Handler,
		},
		{
			MethodName: "Prepare2PC",
			Handler:    _ClientServerTxns_Prepare2PC_Handler,
		},
		{
			MethodName: "Decide2PC",
			Handler:    _ClientServerTxns_Decide2PC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// PaxosReplicationClient is the client API for PaxosReplication service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaxosReplicationClient interface {
	Accept(ctx context.Context, in *LogRecord, opts ...grpc.CallOption) (*AcceptResp, error)
	Commit(ctx context.Context, in *LogRecord, opts ...grpc.CallOption) (*Blank, error)
	Prepare(ctx context.Context, in *PrepareReq, opts ...grpc.CallOption) (*PromiseResp, error)
	NewView(ctx context.Context, in *NewViewReq, opts ...grpc.CallOption) (*Blank, error)
}

type paxosReplicationClient struct {
	cc grpc.ClientConnInterface
}

func NewPaxosReplicationClient(cc grpc.ClientConnInterface) PaxosReplicationClient {
	return &paxosReplicationClient{cc}
}

func (c *paxosReplicationClient) Accept(ctx context.Context, in *LogRecord, opts ...grpc.CallOption) (*AcceptResp, error) {
	out := new(AcceptResp)
	err := c.cc.Invoke(ctx, "/api.PaxosReplication/Accept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosReplicationClient) Commit(ctx context.Context, in *LogRecord, opts ...grpc.CallOption) (*Blank, error) {
	out := new(Blank)
	err := c.cc.Invoke(ctx, "/api.PaxosReplication/Commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosReplicationClient) Prepare(ctx context.Context, in *PrepareReq, opts ...grpc.CallOption) (*PromiseResp, error) {
	out := new(PromiseResp)
	err := c.cc.Invoke(ctx, "/api.PaxosReplication/Prepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosReplicationClient) NewView(ctx context.Context, in *NewViewReq, opts ...grpc.CallOption) (*Blank, error) {
	out := new(Blank)
	err := c.cc.Invoke(ctx, "/api.PaxosReplication/NewView", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaxosReplicationServer is the server API for PaxosReplication service.
// All implementations must embed UnimplementedPaxosReplicationServer
// for forward compatibility
type PaxosReplicationServer interface {
	Accept(context.Context, *LogRecord) (*AcceptResp, error)
	Commit(context.Context, *LogRecord) (*Blank, error)
	Prepare(context.Context, *PrepareReq) (*PromiseResp, error)
	NewView(context.Context, *NewViewReq) (*Blank, error)
	mustEmbedUnimplementedPaxosReplicationServer()
}

// UnimplementedPaxosReplicationServer must be embedded to have forward compatible implementations.
type UnimplementedPaxosReplicationServer struct {
}

func (UnimplementedPaxosReplicationServer) Accept(context.Context, *LogRecord) (*AcceptResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Accept not implemented")
}
func (UnimplementedPaxosReplicationServer) Commit(context.Context, *LogRecord) (*Blank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedPaxosReplicationServer) Prepare(context.Context, *PrepareReq) (*PromiseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (UnimplementedPaxosReplicationServer) NewView(context.Context, *NewViewReq) (*Blank, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewView not implemented")
}
func (UnimplementedPaxosReplicationServer) mustEmbedUnimplementedPaxosReplicationServer() {}

// UnsafePaxosReplicationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaxosReplicationServer will
// result in compilation errors.
type UnsafePaxosReplicationServer interface {
	mustEmbedUnimplementedPaxosReplicationServer()
}

func RegisterPaxosReplicationServer(s grpc.ServiceRegistrar, srv PaxosReplicationServer) {
	s.RegisterService(&PaxosReplication_ServiceDesc, srv)
}

func _PaxosReplication_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRecord)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosReplicationServer).Accept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosReplication/Accept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosReplicationServer).Accept(ctx, req.(*LogRecord))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosReplication_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRecord)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosReplicationServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosReplication/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosReplicationServer).Commit(ctx, req.(*LogRecord))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosReplication_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosReplicationServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosReplication/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosReplicationServer).Prepare(ctx, req.(*PrepareReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosReplication_NewView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewViewReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosReplicationServer).NewView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosReplication/NewView",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosReplicationServer).NewView(ctx, req.(*NewViewReq))
	}
	return interceptor(ctx, in, info, handler)
}

// PaxosReplication_ServiceDesc is the grpc.ServiceDesc for PaxosReplication service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaxosReplication_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.PaxosReplication",
	HandlerType: (*PaxosReplicationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Accept",
			Handler:    _PaxosReplication_Accept_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _PaxosReplication_Commit_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _PaxosReplication_Prepare_Handler,
		},
		{
			MethodName: "NewView",
			Handler:    _PaxosReplication_NewView_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

// PaxosPrintInfoClient is the client API for PaxosPrintInfo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaxosPrintInfoClient interface {
	PrintLog(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Logs, error)
	PrintDB(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Vault, error)
	PrintStatus(ctx context.Context, in *RequestInfo, opts ...grpc.CallOption) (*Status, error)
	// TODO after consensus is implemented
	PrintView(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*ViewLogs, error)
}

type paxosPrintInfoClient struct {
	cc grpc.ClientConnInterface
}

func NewPaxosPrintInfoClient(cc grpc.ClientConnInterface) PaxosPrintInfoClient {
	return &paxosPrintInfoClient{cc}
}

func (c *paxosPrintInfoClient) PrintLog(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Logs, error) {
	out := new(Logs)
	err := c.cc.Invoke(ctx, "/api.PaxosPrintInfo/PrintLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosPrintInfoClient) PrintDB(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*Vault, error) {
	out := new(Vault)
	err := c.cc.Invoke(ctx, "/api.PaxosPrintInfo/PrintDB", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosPrintInfoClient) PrintStatus(ctx context.Context, in *RequestInfo, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/api.PaxosPrintInfo/PrintStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paxosPrintInfoClient) PrintView(ctx context.Context, in *Blank, opts ...grpc.CallOption) (*ViewLogs, error) {
	out := new(ViewLogs)
	err := c.cc.Invoke(ctx, "/api.PaxosPrintInfo/PrintView", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaxosPrintInfoServer is the server API for PaxosPrintInfo service.
// All implementations must embed UnimplementedPaxosPrintInfoServer
// for forward compatibility
type PaxosPrintInfoServer interface {
	PrintLog(context.Context, *Blank) (*Logs, error)
	PrintDB(context.Context, *Blank) (*Vault, error)
	PrintStatus(context.Context, *RequestInfo) (*Status, error)
	// TODO after consensus is implemented
	PrintView(context.Context, *Blank) (*ViewLogs, error)
	mustEmbedUnimplementedPaxosPrintInfoServer()
}

// UnimplementedPaxosPrintInfoServer must be embedded to have forward compatible implementations.
type UnimplementedPaxosPrintInfoServer struct {
}

func (UnimplementedPaxosPrintInfoServer) PrintLog(context.Context, *Blank) (*Logs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintLog not implemented")
}
func (UnimplementedPaxosPrintInfoServer) PrintDB(context.Context, *Blank) (*Vault, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintDB not implemented")
}
func (UnimplementedPaxosPrintInfoServer) PrintStatus(context.Context, *RequestInfo) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintStatus not implemented")
}
func (UnimplementedPaxosPrintInfoServer) PrintView(context.Context, *Blank) (*ViewLogs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintView not implemented")
}
func (UnimplementedPaxosPrintInfoServer) mustEmbedUnimplementedPaxosPrintInfoServer() {}

// UnsafePaxosPrintInfoServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaxosPrintInfoServer will
// result in compilation errors.
type UnsafePaxosPrintInfoServer interface {
	mustEmbedUnimplementedPaxosPrintInfoServer()
}

func RegisterPaxosPrintInfoServer(s grpc.ServiceRegistrar, srv PaxosPrintInfoServer) {
	s.RegisterService(&PaxosPrintInfo_ServiceDesc, srv)
}

func _PaxosPrintInfo_PrintLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Blank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosPrintInfoServer).PrintLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosPrintInfo/PrintLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosPrintInfoServer).PrintLog(ctx, req.(*Blank))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosPrintInfo_PrintDB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Blank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosPrintInfoServer).PrintDB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosPrintInfo/PrintDB",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosPrintInfoServer).PrintDB(ctx, req.(*Blank))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosPrintInfo_PrintStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosPrintInfoServer).PrintStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosPrintInfo/PrintStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosPrintInfoServer).PrintStatus(ctx, req.(*RequestInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaxosPrintInfo_PrintView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Blank)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaxosPrintInfoServer).PrintView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.PaxosPrintInfo/PrintView",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaxosPrintInfoServer).PrintView(ctx, req.(*Blank))
	}
	return interceptor(ctx, in, info, handler)
}

// PaxosPrintInfo_ServiceDesc is the grpc.ServiceDesc for PaxosPrintInfo service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaxosPrintInfo_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.PaxosPrintInfo",
	HandlerType: (*PaxosPrintInfoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PrintLog",
			Handler:    _PaxosPrintInfo_PrintLog_Handler,
		},
		{
			MethodName: "PrintDB",
			Handler:    _PaxosPrintInfo_PrintDB_Handler,
		},
		{
			MethodName: "PrintStatus",
			Handler:    _PaxosPrintInfo_PrintStatus_Handler,
		},
		{
			MethodName: "PrintView",
			Handler:    _PaxosPrintInfo_PrintView_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}
